####   进程\线程

**进程**

+ 独立性：进程是系统进行资源分配的和调度的一个独立单位
+ 结构性：进程由程序、数据、进程控制块三部分组成
+ 动态性：进程是程序的一次执行过程，是临时的，有生命周期的，是动态产生、动态消亡的
+ 并发性：任何进程都可以同其他进程一起并发执行

**线程**：是cpu调度和执行工作的基本单元（包括线程栈和内核对象）

**进程与线程的区别与联系：**

+ 一个进程由一个或多个线程组成
+ 进程之间相互独立，但同一个进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
+ 线程上下文切换比进程上下文切换要快的多

```c++
//vs创建线程
CreateThread(NULL,			//安全等级
            0,				//线程栈大小，默认1MB
            &ThreadProc,	//线程函数的地址
            (void*)666,		//线程函数的参数
            0,				//创建线程的初始状态，0-创建即执行，CREATE_SUSPENDED-创建即挂起
            NULL			//线程ID)
```

```c++
_beginThreadex是c|c++运行时库里的函数，是对CreateThread的封装
```

每个线程分配一个stack，每个进程分配一个heap

**内核对象**

​	每一次对CreateThread()成功调用，系统就会在内部为新的线程分配一个内核对象。内核对象是实现线程管理的函数，通过句柄我们可以得到内核对象，内核对象是提供给用户与系统内核之间交互的接口，内核对象包含计数器、挂起计数器、信号、以及线程上下文等

个人理解：内核对象用于管理进程、线程和文件等诸多种类的大量资源。进程的虚拟内存空间分为内核层和应用层，每个内核对象，其实就是一块内存块，这个内存块位于操作系统的内核地址空间（内核层），而用户的应用程序运行在应用层，内核对象是由操作系统内核分配的，并只能由操作系统内核访问。因此，应用程序不能直接操作内核对象，需要用Windows系统给定的函数来操作。每一个内核对象都有特定的创建函数和操作函数。



**线程退出**：线程退出时会有信号

```c++
if(handle){
	quitflag = true;
    if(WAIT_TIMEOUT == WaitForSingleObject(handle,100)){	//阻塞函数，如果线程没有结束成功（可能线程中有循环的工作）
        TerminateThread(handle,-1);
    }
    CloseHandle(handle);	//关闭句柄（内核对象），计数器减一
    handle = NULL;
}
SuspendThread();	//挂起计数器+1
ResumeThread();		//挂起计数器-1
```

**线程的基本状态**

![image-20220917215859549](os.assets/image-20220917215859549.png)



**sleep不能精准延时：**sleep的时间是告诉系统多长时间内不占用时间片，进入阻塞态，时间过后，进入就绪状态，线程被添加到就绪队列中，等待时间片的轮换。

**并发问题：**多个线程或进程同时对一个资源进行读写操作，而导致结果错误或多次执行结果不一致

**解决并发问题的办法：线程同步**

**线程同步：**通过协调线程执行的顺序，避免多个线程同时操作同一个资源导致并发问题，使多次执行结果一致

**线程同步方式（win)：**原子访问、关键段、内核对象：互斥量 （同一时刻只允许一个线程访问一个代码段）、事件（人工事件）、信号（因为可以设置初始化的信号数量，所以可以控制指定线程数工作）

互斥量与关键段的区别：1.作用范围（关键段只能在一个进程中使用，互斥量可以在不同进程使用）

​										   2.灵活、安全（互斥量更灵活和安全，因为可以设置等待时间，如果拥有互               												斥量的进程或者线程被强制结束，互斥量会被释放）

​										   3.效率（关键段效率更高，互斥量每次使用要切换到内核模式）	

**进程间通信(win)：**事件、互斥量、信号量、dll、SOCKET、消息、共享内存

+ 关键段（临界区） 同一时刻只允许一个线程访问一个代码段

+ （1）直接阻塞

  （2）旋转锁（等待一会，还是运行态，如果一段时间过后，还在阻塞，变为阻塞态）

  （3）异步

+ 注意事项：

  （1）在同一进程

  （2）如果关键段中的线程被强制杀死，会影响其他线程

```c++
#include<Windows.h>
class MyCrit
{
private:
	CRITICAL_SECTION cs;
public:
	MyCrit()
	{
		InitializeCriticalSection(&cs);
	}
	~MyCrit()
	{
		DeleteCriticalSection(&cs);
	}
	void Lock()
	{
		EnterCriticalSection(&cs);
	}
	void UnLock()
	{
		LeaveCriticalSection(&cs);
	}
	
};
```



#### 进程切换上下文

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行

+ 保护被中断进程的处理器现场信息

+ 修改被中断进程的进程控制块有关信息，如进程状态等

+ 把被中断进程的进程控制块加入有关队列
+ 选择下一个占有处理器运行的进程
+ 根据被选中进程设置操作系统用到的地址转换和存储保护信息
  + 切换页目录以使用新的地址空间
  + 切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）

+ 根据被选中进程恢复处理器现场

#### 线程切换上下文

+ 保护被中断线程的处理器现场信息

+ 修改被中断线程的线程控制块有关信息，如线程状态等

+ 把被中断线程的线程控制块加入有关队列

+ 选择下一个占有处理器运行的线程

+ 根据被选中线程设置操作系统用到的存储保护信息
  + 切换内核栈和硬件上下文（切换堆栈，以及各寄存器）

+ 根据被选中线程恢复处理器现场

#### 多线程和多进程

+ 一个线程属于一个进程，一个进程包含多个线程
+ 一个线程挂掉，对应的进程挂掉，多线程也挂掉。一个进程挂掉，不会影响其他进程，多进程稳定
+ 进程系统开销显著大于线程开销。线程需要的系统资源更少
+ 多个进程在执行时拥有各自独立的内存单元。多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
+ 通信方式不一样

#### 用户态和内核态

​	用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在**用户态**执行，而当程序使用内核空间时，程序则在**内核态**执行。

**应用程序如果需要进入内核空间，就需要通过系统调用**

![](os.assets/image-20220911221353170.png)

​	内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。

​	内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。

什么时候进入内核态：系统调用、异常、中断

#### 中断

​	中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。

**为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」**。

- **上半部用来快速处理中断**，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。
- **下半部用来延迟处理上半部未完成的工作**，一般以「内核线程」的方式运行。

**硬中断：主要是负责耗时短的工作，特点是快速执行**

**软中断：主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；**



#### 缺页中断

+ **缺页异常**：malloc和mmap函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个**缺页异常，引发缺页中断**。
+ **缺页中断**：缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的**外存地址**在外存中找到所缺的一页，将其调入**内存**。
+ **一般中断和缺页中断的区别：**缺页中断与一般中断一样，需要经历四个步骤：保护CPU现场、分析中断原因、转入缺页中断处理程序、恢复CPU现场，继续执行。 缺页中断与一般中断区别： （1）在指令执行期间产生和处理缺页中断信号 （2）一条指令在执行期间，可能产生多次缺页中断 （3）缺页中断返回的是执行产生中断的一条指令，而一般中断返回的是执行下一条指令。



#### **分时复用原则**

​	多任务操作系统，cpu转移复用是一个重要特征，可以让多进程共享cpu资源，每个进程会以时间片为单位使用特定时长，交替使用

#### **保存与恢复处理器现场**

​	解决寄存器冲突的问题

​	cpu用来保存临时数据的寄存器有限，为了让多进程很好地使用寄存器不引发冲突，在进程切换时通过保存/恢复处理器现场（保存临时数据及运算过程）的方式多进程共享使用寄存器，每一个进程被中断继续后都能正常向下执行，一个成熟的多任务系统，分时复与保存恢复处理器现场，这两个都是不可获取的。

#### 死锁

​	当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

- 互斥条件；
- 持有并等待条件；
- 不可剥夺条件；
- 环路等待条件

#### Linux虚拟内存分布

![](os.assets/image-20220911221628626.png)

+ 代码段：存放程序执行代码
+ 数据段：存放程序中已经初始化的全局变量和静态变量的一块内存区域
+ BSS段：存放未初始化的全局变量和静态变量的一块内存区域
+ 堆区：动态申请内存用，堆从低地址向高地址增长
+ 共享区：包括动态库和共享内存等，低地址向高地址增长
+ 栈区：包括局部变量、函数参数值、函数调用的上下文等、
+ 命令行参数
+ 环境变量
+ PCB

#### 虚拟内存

​	操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。主要有两种方式，分别是**内存分段和内存分页**

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（*Page*）

![](os.assets/image-20220911221657068.png)

页表是存储在内存里的，**内存管理单元** （*MMU*）就做将虚拟内存地址转换成物理地址的工作。

内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而**采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。**

但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对**内存分页机制会有内部内存碎片**的现象。

**在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。**

![](os.assets/image-20220911221711063.png)

**总结一下，对于一个内存地址转换，其实就是这样三个步骤：**

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 `4MB` 的内存来存储页表。

**多级页表**

![](os.assets/image-20220911221723830.png)

如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= `0.804MB`，这对比单级页表的 `4MB` 是不是一个巨大的节约？

**TLB**

把最常访问的几个页表项存储到访问速度更快的硬件，在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，**这个 Cache 就是 TLB（*Translation Lookaside Buffer*）** ，通常称为页表缓存、转址旁路缓存、快表等。

**段页式内存管理**

段页式内存管理实现的方式：

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

![](os.assets/image-20220911221738007.png)

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

#### malloc

​	malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存，虚拟内存

- 方式一：通过 brk() 系统调用从堆分配内存
- 方式二：通过 mmap() 系统调用在文件映射区域分配内存；

方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。如下图：

![image-20220919142722421](os.assets/image-20220919142722421.png)

方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：

![image-20220919142744120](os.assets/image-20220919142744120.png)

**什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？**

malloc() 源码里默认定义了一个阈值：

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

#### **volatile**

​	提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

#### 大小端

**大异小同**

大端：低地址存数据的高位，网路字节序

小端：低地址存数据的地位，x86，ARM

![image-20220913200637252](os.assets/image-20220913200637252.png)

```c++
void judge_bigend_littleend()
{
    union
    {
        int i;
        char c;
    }un;
    un.i = 1;

    if (un.c == 1)
        printf("小端\n");
    else
        printf("大端\n");
}
```

```c++
void judge_bigend_littleend()
{
    int i = 1;
    char c = (*(char*)&i);

    if (c)
        printf("小端\n");
    else
        printf("大端\n");
}
```

#### 库

+ 静态库：可以看成是一组目标文件（.o/.obj）的集合，在链接阶段将代码直接插入到生成的可执行文件中，会导致体积变大，但是只需要一个文件就可以运行

  **缺点：**

  + 空间浪费
  + 静态库对程序的更新、部署会带来麻烦。如果静态库更新了，所有使用它的程序都需要重新编译、发布给用户（对用户来说只是很小的更新，却需要重新下载程序）

+ 动态库：在链接阶段，将引入库（函数名，函数位置）拷贝到.exe中。(.lib 动态库的导入库 .dll动态库)（exe和dll在同级目录下运行）。

无论是静态库或者是动态库，都需要lib,静态库中本身就包含了实际执行的代码，而导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。其实际的执行代码位于动态库中

如果想要使用库文件，需要引入头文件(动态库的显示加载不需要），要不然会发生编译错误，因为库文件在链接阶段生效。

静态库中的所有代码外面可以直接用

动态库中的所有代码为私有的

**将函数和类导出为外界可用有两种方式：**

1. 适用于类和函数，导出为程序类型

   ![image-20220914011333984](os.assets/image-20220914011333984.png)

2. 添加->新建项->代码->模块定义文件（适用于函数，不适用于类，以c语言导出）

   ![image-20220914011344438](os.assets/image-20220914011344438.png)

   LIBRARY+库的名字   @+函数的位置

   ```c++
   extern "C"	//以什么语言进行编译
   ```

   

**使用库：**

0. 拷贝库文件和头文件到当前工程下

1. 导入依赖库
2. 添加依赖库的头文件

**导入库的三种方式：**

1. 

```c++
#pragma comment(lib,"./lib/static.lib");	//隐式加载，在链接期加载 
```

2. 属性->链接器->附加依赖项->相对路径

3. 动态库特殊的加载方式：显示加载，运行时加载，只需要.dll

   ```c++
   //1. 加载库
   HMODULE hMoudle = LoadLibrary(L"Lib.dll");
   //2. 获取函数地址
   PFUN pfun = (PFUN)GetProcAddress(hMoudle,"add");
   cout<<(*pfun)(6,6)<<endl;
   //3. 卸载库
   FreeLibrary(hMoudle);
   ```





#### fork

​	fork()调用一次返回两次（两个进程执行一个函数），在父进程中返回子进程的pid(pid > 0)，在子进程中返回0(pid==0)

**读共享，写复制**

​	fork创建子进程的时候，系统为了减少损耗，并不是一开始就复制了一份物理内存给子进程，而是复制了一份虚拟地址给子进程，父子进程的虚拟地址映射到相同的物理地址。该物理地址被标记为只读。当系统需要对该地址进行写的时候，此时系统才会调用exec函数给子进程复制一份自己的物理地址，然后他们各自的物理地址被标记为可写。

```c
pid_t pid = getpid()	#返回调用进程的id;
pid_t pid = getppid()	#返回调用进程父进程的id
```

**execve系统函数：**

+ execl：每一个参数都为字符串
+ execle：自定义环境变量
+ execlp：无需填写命令的详细地址
+ execv：将参数放在数组中，然后传递数组地址
+ execvp

```c
execl("/home/zh/proc/copy","copy",argv[1],argv[2],index,size,NULL);
execlp("./copy","copy",argv[1],argv[2],index,size,NULL);
//如果子进程需要完成自定义任务，需要在fork()之后，execl()之前完成
```



#### 僵尸进程

​	父子进程模型中，子进程先于父进程结束，父进程又没有回收子进程，子进程会先变为僵尸进程

危害：

+ 有内存泄露（PCB是庞大的结构体，内部成员众多许多成员还额外占用内存空间）
+ 僵尸进程导致PCB残留，影响新进程的创建

```c
pid_t pid = wait(int *status);	//阻塞回收，父进程通过该函数回收子进程的资源
pid_t pid = waitpid(pid_t pid,int *status,int opt);	//默认情况下waitpid()也是阻塞回收，可以通过设置opt设置为非阻塞
argument pid:
-1:回收任意子进程;
>0:通过pid指定回收一个子进程;
0:同组回收方案，可以帮助调用进程将本进程组所有子进程回收;
<0:跨组回收方案，-pgid,到指定进程组回收子进程;
argument status:
回收成功传出子进程的结束原因,父进程可以校验，如果不需要则传NULL;
argument opt:
WNOHANG:非阻塞关键字;
return value:
-1:回收失败;
>0:回收成功，返回僵尸进程的pid;
0:非阻塞返回
```

#### 进程间通信

消息队列（SystemV，Posix）

 管道（匿名管道PIPE，命名管道FIFO）

内存共享映射（mmap）

网络套接字（socket)

信号（signal)



##### **管道**

**匿名管道（PIPE）**

使用pipe在内核空间创建一个缓冲区（环形队列）大小为4kB.，创建管道返回两个描述符，fd[0]为读端描述符，fd[1]为写端描述符，使用匿名管道，必须确定通信的方向，例如，父写子读，父子进程要将自身不用的那端关掉

**特性**

+ 流通性（可以利用此介质传递）
+ 暂存数据
+ 方向性（数据流通方向）

```c
#include<unistd.h>
int pipe (int fd[2])
```

**特殊情况**

+ 写端存在未向管道写数据，读端读取管道内数据，管道为空读端阻塞
+ 写端结束，读端读取完管道剩余的内容，再次读返回-1，读取结束
+ 读端存在但未读数据，写端持续向管道内写数据，写满管道后，写端阻塞
+ 读端结束，写端尝试向管道内写数据，内核向写端发送信号，杀死写端进程

**缺点**

1. 使用受限，只能完成亲缘间进程通信（父子进程）
2. 默认传输无格式字节流（不便于读取解析与处理）
3. 单工使用

**有名管道 FIFO**

​	有名管道帮助Linux下不相干的进程完成数据通信

+ 创建管道文件，管道文件类型为P，创建管道文件时命名 mkfifo tmp

+ ```c
  mkfifo(const char &name,int mod);	//函数创建
  ```

+ 并不是利用管道文件进行数据交互，管道文件与常规文件不同，没有存储能力

+ 有名管道使用时必须满足读写访问两种权限，才可以使用管道缓冲区，如果只有一种权限，那么会阻塞，等待另一种，但是一个进程满足两种权限，一样可以访问管道

**特殊情况**

+ 管道模型为一个写端，多个独端，阻塞只对第一个读端生效，如果管道内没数据其他读端立即返回（多线程读，同属于一个进程，一个线程为阻塞读，其他线程可以为非阻塞
+ 写端写入数据量小于管道大小，为原子写
+ 写端写入数据量大于管道大小，为非原子写（传输效率高，速度较快开销小，用户需要校验，保证数据包完整）

##### mmap内存共享映射

![](os.assets/image-20221002123205303.png)

+ 映射内存大小与映射文件的大小相等
+ 映射方式：
  + 共享映射(MAP_SHARED)，sync同步机制，映射文件数据与映射内存数据实时同步
  + 私有映射(MAP_PRIVATE)，私有映射会将映射文件的内容复制一份给映射内存
+ 数据加载：使用mmap记载磁盘数据比传统的read或fread高效
+ 大文件处理：使用mmap对大数据文件进行分段映射，并发处理‘

```c
#include<sys/mman.h>
void *ptr = mmap(NULL,filesize,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
arg1:映射内存地址，使用者可以自行申请内存空间，作为映射内存，如果该参数为NULL，会自行申请一块内存;
arg2:映射大小;
arg3:映射内存权限,PROT_WRITE,PROT_READ,PROT_EXEC,PROT_NONE;
arg4:映射方式,MAP_SHARED,MAP_PRIVATE;
arg5:映射文件描述符;
arg6:映射偏移量;
//多线程拷贝，通过主函数参数传进去源文件的文件描述符，在主线程中，定义一个全局变量的指针，用来做文件映射使用，所有线程都可以使用到，给线程传参数时，要传开始拷贝下标和大小，所以，要传结构体
```



##### 信号

+ kill 命令
+ kill -signo pid 终止特定进程
+ kill -signo -pgid 终止特定进程组
+ kill -l 查看所有系统支持的信号
+ 信号分类：
  + 1-31：unix经典信号
  + 34-64：自定义信号/实时信号
  + 32、33：隐藏预留给NPTL线程库使用



+ linux下触发信号的几种方式

  + 终端组合按键产生信号（只对前台进程有效）

    1. ctrl+c (SIGINT|2) 结束进程

    2. ctrl+\ (SIGUIT|3)  退出进程（核心转储）

    3. ctrl+z (SIGTSTP|20) 挂起进程

       通过jobs命令查看挂起的作业编号

       fg 作业编号(唤醒到前台继续执行)

       bg 作业编号(唤醒到后台继续执行)

  + 命令产生信号

  + 函数发送信号

    ```c
    kill(pid_t pid,int signo);	//向任意进程发送任意信号
    raise(int signo);	//向调用进程发送信号
    abort(void);	//向自身进程发送固定的SIGABRT
    sigueue(pid_t pid,int signo,union sigval);	//向任意进程发送任意信号并且携带自定义数据包
    ```

  + 硬件异常触发信号

    对内存进行非法使用(段错误)	SIGSEGV|11

    CPU运算异常(浮点数例外)		SIGFPE|8

    堆栈异常，调度异常(总线错误)	SIGBUS|7

  + 软条件触发信号

    读端终止，写端向管道写数据（软条件触发）内核向写端发送信号（SIGPIPE|13）

    定时器开始计时定时器到时（软条件触发）内核向定时进程发送信号（SIGALRM|14）

    unsigned int alarm(unsigned int seconds)	参数为定时的秒数，返回未定时购得秒数

+ 信号的三大行为与五种默认处理动作

  行为三选一，不选位默认进程

  ![image-20221002124942790](os.assets/image-20221002124942790.png)

+ 信号传递过程

  向进程控制块PCB的task_struct中写入数据，内核发送信号，通过未决信号集变为未决信号，通过屏蔽字，变为递达信号，通过函数指针进行信号行为

  ![image-20221002133032618](os.assets/image-20221002133032618.png)

  通过未决信号集的信号，状态为未决信号

  通过屏蔽字信号集的信号，状态为递达态信号

  当某信号处于未决态时，内核将其未决信号集位设置为1，该信号转换为递达态，设置为0



+ 信号失效的三种方式

  + 信号屏蔽

    定义一个新的信号集，将信号集初始化为0，把想要屏蔽的信号位，通过sigaddset置为1，然后通过sigprocmask来替换信号集

    ```c
    sigset_t newset,oldset;	//信号集类型
    sigemptyset(sigset_t set);	//初始化信号集，将所有信号位初始化为0
    sigfillset(sigset_t *set);	//初始化信号集，将所有信号位初始化为1
    sigaddset(sigset_t *set,int signo);	//对信号集中某一个信号位置1
    sigdelset(sigset_t *set,int signo);	//对信号集中某一个信号位置0
    int reval = sigismember(sigset_t *set,int signo);	//查看某信号集，特定信号位是0还是1
    sigprocmask(SIG_SETMASK,&newset,&oldset);	//替换信号集,oldset如果部位NULL,会接收到当前的信号集
    ```

  + 信号忽略

    定义新的信号行为结构体，里面自行更换设置信号行为newact.sa_handler=SIG_IGN，可以变为忽略行为，也可以变为捕捉行为，用sigaction()来修改信号的行为

    ```c
    struct sigaction newact,oldact;	//信号行为结构体
    newact.sa_handler = SIG_DFL|SIG_IGN|SIG_ACTION;
    newact.sa_flags = 0;	//如果行为设置用handler,flags = 0
    newact.sa_mask;	//临时屏蔽字，避免多信号绑定相同的捕捉函数，引发调用异常或冲突，可以设置临时屏蔽字，在处理信号时屏蔽其				  他信号，避免冲突
    sigaction(int signo,struct sigaction *newact,struct sigaction *oldact);	//修改信号的行为，将原有行为覆盖
    ```

  + 信号捕捉

    定义一个新的信号行为结构体，按信号行为结构体中函数指针类型，定义实现捕捉函数，而后进行设置，将捕捉函数的地址存储到行为结构体中newact.handler = action;最好在设置一下sa_mask,在执行捕捉函数时，屏蔽其他信号，避免冲突

    ```c
    void (*sa_handler)(int);	//此接口捕捉函数，不支持用户传参，参数默认传递被捕捉的信号编号
    if sa_handler.sa_flags = 0;
    void(*sa_sigaction)(int,siginfo_t*,void*);	//支持用户自定义传参或利用信号进程通信
    if sa_sigaction.sa_flags = SA_SIGINFO;
    ```

+ 利用信号技术，优化僵尸进程回收

  父子进程模型，当子进程结束，内核向其父进程发送SIGCHLD(IGN)信号，通知父进程进行回收处理，可以将SIGCHLD信号进行捕捉设置，捕捉函数完成回收操作

+ 高权集信号

  + SIGKILL：只要发出必然杀死，无法失效
  + SIGSTOP：只要发出必然挂起，无法失效

#### 进程间关系

##### 进程组关系

+ 进程组构成：由一个组长进程与若干的组员构成（一般进程组时组长进程创建的）

+ ps ajx：查看进程间关系

+ 进程组组长标识：PID==PGID

+ 终端进程被创建默认就是组长进程

+ 终端进程传创建多个子进程（就近原则）将所有子进程归纳到父进程同组（成为组员）

+ 进程组的创建与销毁：一般由组长进程创建，进程组为空，内核回收该组

+ ```c++
  kill -9 -PGID;
  pid_t getpgrp(void);	//返回当前进程的组PGID
  pid_t setpgid(pid_t pid,pid_t pgid);	//设置进程组，将一个进程转移到其他组中，也可以创建新组，使用时两个参数都传递相										  同的进程pid，为创建新组，创建进程组只允许组员进行
  ```

  

##### 进程会话关系

+ 进程会话关系构成：由一个会话发起者与若干个会话参与者构成

+ 会话发起者唯一标识：PID==PGID==SID

+ 会话发起者如果结束，会以组为单位结束会话参与者

+ 所有终端下执行的程序或进程都属于终端进程受限与会话

+ ```c
  getsid(pid_t pid);	//返回当前进程的会话id,参数为进程PID
  void setsid(void);	//为调用进程创建一个会话，为组员进程创建组并创建新会话
  ```

##### 孤儿进程

+ 产生原因：父进程因异常原因结束退出，子进程变为孤儿进程，父进程结束，系统托管进程负责接收孤儿进程

##### **守护进程（精灵进程）**

+ 特征
  + 孤儿进程后台执行
  + 守护进程声明周期较长（随系统持续）
  + 后台执行（周期暂停，条件触发）
+ 实现步骤
  + 创建子进程
  + 父进程终止退出
  + 子进程创建新会话，脱离原有控制终端
  + 关闭无用文件描述符（后台服务进程不允许访问前台）

#### 线程

+ 线程间共享资源
  + 全局资源
  + 共享堆
  + 文件描述符
  + 进程工作目录
  + PID、PGID、用户ID、用户组ID
  + 信号行为共享
  
+ 非共享资源
  + 线程栈
  + 线程屏蔽字
  + 线程信息（TCB）
  + 线程调度优先级
  + ERRNO(全局变量）非共享
  
+ 多进程
  + 优点：可以获取更多系统资源（使用CPU），稳定性更好
  + 缺点：系统开销较大，切换上下文，调度缓慢
  
+ 多线程
  + 优点：开销小，更轻量
  + 缺点：稳定性比较差（线程崩溃导致进程终止），相较于多进程模型需要注意的开发细节更多（互斥、死锁）

+ 使用NPTL线程库中的方法，编译时必须链接线程库

  ```bash
  libpthread.so
  gcc *.c -lpthread -o app
  ```

+ 线程查看命令

  ```bash
  ps -eLf	//查看系统所有线程信息
  ps -Lf pid	//查看指定进程中的线程信息
  ```

+ ```c
  //线程创建
  pthread_t tid;	//线程id类型
  int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void*),void *arg);
  arg1:线程创建成功，内核将线程id传出到thread变量中;
  arg2:线程属性，传NULL标识使用默认线程属性;
  arg3:线程工作地址，开发者定义线程任务并实现，线程创建后开始执行;
  arg4:线程工作参数;
  return value:
  成功返回0，失败返回错误号;
  ```
  
+ ```c
  //线程退出
  void pthread_exit(void *retval);
  //参数为线程退出码(整型)，其他线程可以对退出码回收检验;
  ```

+ ```c
  //线程id获取
  pthread_t pthread_self(void);
  ```

+ ```c
  //线程回收，阻塞回收
  int pthread_join(pthread_t thread,void **retval);
  //如果一个线程是回收态线程，那么线程退出后需要join回收，否则会引起内存泄漏;
  //retval:回收成功传出线程的退出码或返回值
  //除主控线程外，其他线程也可以通过线程id进行回收;
  ```

+ ```c
  //线程分离
  int pthread_detach(pthread_t thread);
  ```

+ 线程的错误处理：判断线程函数的返回值，如果返回值大于0，标识该函数可能调用失败，返回值中存储了对应的错误号，通过strerror()，获取错误信息

+ 线程退出状态

  + pthread_joinable：线程回收态，线程结束后需要手动回收资源
  + pthread_detached：线程分离态，线程结束后内核自动回收资源
  + 对一个已经设置成分离态的线程进行回收操作，回收操作失败
  + 对一个已经处于回收阶段(join阻塞)的线程，进行分离设置，分离失败
  + 默认情况下，所有被创建出的线程都是回收态线程，但是可以通过两种方式将其改变为分离态，一旦被设置为分离态，则无法逆转

+ ```c
  //线程取消
  int pthread_cancel(pthread_t thread);
  //参数为要取消的线程id,可以通过该函数取消其他线程,线程取消没有限制,只要可以得到对方id,就可以取消
  //线程取消需要被取消的线程需要系统调用,否则无法结束
  void pthread_testcancel(void);
  //该函数只产生一次系统调用
  ```

+ ```c
  //线程间信号传递
  int pthread_kill(pthread_t thread,int sig);
  //向指定线程发送任意信号
  ```

+ ```c
  //线程属性
  //线程属性包括线程优先级，线程警戒缓冲区，线程权重指针，线程状态，线程栈大小，线程栈地址
  pthread_attr_t attr;	//线程属性类型
  pthread_attr_init(pthread_attr_t *attr);
  pthread_attr_destroy(pthread_attr_t *attr);
  
  //修改线程属性中的退出状态
  pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate);
  //对线程属性进行设置，将其中的状态设置为分离或回收
  pthread_attr_getdetachstate(pthread_attr_t *attr,int *detachstate);
  //获取属性中的退出状态，传出到detachstate变量中
  ```

+ 两种线程设置分离态的方式

  + pthread_detach()：分离设置有可能失败
  + 修改线程属性：时效性更强，因为线程一创建就是分离线程

+ 何时使用函数设置分离，何时使用属性设置分离？

  + 多线程模型中，对分离线程批创建，修改属性设置分离
  + 多线程模型中，退出状态是混合型，采用函数延迟设置

+ 修改属性中的线程栈信息，提高线程创建数量

  ```c
  int pthread_attr_setstack(pthread_attr_t *attr,void *stackaddr,size_t stacksize);
  int pthread_attr_getstack(const pthread_attr_t *attr,void *stackaddr,size_t *stacksize);
  //线程属性中栈地址需要使用者自行申请，并设置到线程属性，只设置线程栈大小，不申请地址，该设置时无效的
  ```

  

#### **线程间通信**

+ 多线程访问互斥（解决多线程访问共享资源冲突问题）

+ 互斥锁

  ```c
  pthread_mutex_t;	//互斥锁类型
  pthread_mutex_init(pthread_mutex_t *lock,pthread_mutexattr_t *attr);
  arg1:互斥锁地址;
  arg2:互斥锁属性地址，=NULL表示使用默认互斥锁属性;
  
  pthread_mutex_destroy(pthread_mutex_t *lock);
  //使用destroy对互斥锁进行回收释放
  pthread_mutex_lock(pthread_mutex_t *lock);
  //上锁，创建临界区
  pthread_mutex_unlock(pthread_mutex_t *lock);
  //解锁
  ```

+ 读写锁

  ```c
  //允许多个线程访问全局资源，读共享，写独占，读写互斥
  pthread_rwlock_t;	//读写锁类型
  pthread_rwlock_init(pthread_rwlock_t *lock,pthread_rwlockattr_t *attr);
  arg1:读写锁地址;
  arg2:读写锁属性，=NULL使用默认读写锁属性;
  pthread_rwlock_destroy(pthread_rwlock_t *lock);
  //使用destroy对读写锁进行回收释放
  pthread_rwlock_rdlock(pthread_rwlock_t *lock);
  //申请读锁
  pthread_rwlock_wrlock(pthread_rwlock_t *lock);
  //申请写锁
  pthread_rwlock_unlock(pthread_rwlock_t *lock);
  //解除读写锁
  ```

+ 文件锁

  基本特征与读写一致，使用文件锁要学会修改设置文件属性（文件锁属性）

  ```c
  struct flock;	//文件锁属性类型
  l_type= F_RDLCK|F_WRLCK|F_UNLCK;	//文件锁设置关键字
  l_whence = SEEK_SET|SEEK_CUR|SEEK_END;	//上锁的起始位置，绝对偏移量
  l_start= 0;	//相对偏移量
  l_len = 0;	//上锁长度，如果为0，默认上锁整个文件大小
  l_pid;	//可以通过获取文件锁属性，查看pid，了解那个进程对文件进行了锁设置
  
  fcntl(int fd,int flags,struct flock *lock);	//文件属性设置函数
  arg1:设置文件的描述符;
  arg2:文件的操作方式，F_SETLKW(阻塞设置)，F_SETLK(非阻塞设置)，F_GETLK(获取属性);
  ```

  

+ 进程锁

  多进程访问共享资源也要通过互斥锁限制资源访问，否则发生冲突，可以通过修改互斥锁属性，将线程互斥锁变更为进程互斥锁

  ```c
  pthread_mutexattr_t;	//互斥锁属性类型
  pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,int shared);	//修改互斥锁属性中的互斥锁类型
  PTHREAD_PROCESS_SHARED;	//进程互斥锁关键字
  PTHREAD_PROCESS_PRIVATE;	//线程互斥锁关键字
  ```

+ 旋转锁

  旋转锁与互斥锁不同之处在于不会阻塞，不停尝试申请，一直到成功获取资源为止，相比互斥锁，旋转锁的有效性更强，实时申请获取资源，互斥锁属性延时使用（阻塞）

  旋转锁系统开销较大，进程等待处于R

  互斥锁开销较小，进程等待处于S

+ 条件变量

  经典的线程控制方式，可以根据特定条件控制线程，将线程挂起或者唤醒，生产者消费者模型就是该技术的典型应用
  
  条件变量可以简单理解为线程的挂起点，多线程可以挂在一个条件变量中，也可以唤醒这些线程，线程被挂起在那个条件变量上取决于条件
  
  ```c
  pthread_cond_t;	//条件变量类型
  pthread_cond_init(pthread_cond_t *cd,pthread_condattr *attr);
  pthread_cond_destroy(pthread_cond_t *cd);
  pthread_cond_wait(pthread_cond_t *cd,pthread_mutex_t *lock);
  //两次调用:
  //第一次调用:挂起当前线程并解锁互斥锁
  //第二次调用:被唤醒后上锁互斥锁
  pthread_cond_signal(pthread_cond_t *cd);
  //随机唤醒一个被挂起在某条件变量上的线程;
  pthread_cond_broadcast(pthread_cond_t *cd);
  //唤醒所有被挂起在某条件变量上的线程
  ```
  
  



